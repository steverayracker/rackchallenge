#!/usr/bin/python
import datetime
import itertools
import pyrax
import argparse
import logging as log
import ConfigParser
import configobj
from configobj import ConfigObj
import os,sys
import re
import signal
import errno
import warnings
import keyring
import traceback

#
# The Tempest - a Rackspace cloud command and control script using the pyrax bindings to the OpenStack API
# https://en.wikipedia.org/wiki/The_Tempest
# All apologies to Wm. Shakespeare
#Dramatis Personae 
# Prosepero   - the magister gives the commands
#               https://en.wikipedia.org/wiki/Prospero
#               command process control and argument interpreter
# Miranda     - the witness to it all and the future
#               https://en.wikipedia.org/wiki/Miranda_%28The_Tempest%29
#               configuration management and prefab generation tools
# Caliban     - the slave who does all the work
#               https://en.wikipedia.org/wiki/Caliban_%28The_Tempest%29
#               argument setup and processing
# Ariel       - the performer of the real magic
#               https://en.wikipedia.org/wiki/Ariel_%28The_Tempest%29
#               class using pyrax to make API calls
#

# Globals
global logfile
# Defaults
default_base = os.path.expanduser("~/.tempest")
default_pyrax = os.path.expanduser("~/.pyrax.cfg")
default_nets = {'public': True, 'private': True}
default_config = 'tempest_defaults.cfg'
default_html = "<html>Default %s index.html</html>" %__file__
logfile = os.path.join(default_base,'logs','tempest.log')
prefab_lilst = os.path.join(default_base,'prefabs','prefab.lst')
default_sections = ["tempest","server","dns","files","db","lb",'net','cbs']

tempest_objects=['config','auth','prefab']
cloud_objects=['server','image','flavor','dns','cloudfiles','cdn','clouddb','db','dbauth','cloudlb','lbnode','ssl','cbs','snap','net']
common_actions=['list', 'show','add', 'delete', 'rename', 'edit', 'clone','on','off']
prefab_actions=['run']
server_actions=['resize', 'revert', 'confirm','reboot']
db_actions=['resize']
#db_actions=[]
files_actions=['upload','download','sync']
dns_actions=['import','export']
#lb_actions=[]
bs_actions=['attach','detach']

all_objects = tempest_objects + cloud_objects
#all_actions = common_actions + prefab_actions + server_actions + dns_actions + files_actions + db_actions + lb_actions + bs_actions
all_actions = common_actions + prefab_actions + server_actions  + files_actions + dns_actions + bs_actions

warnings.filterwarnings(
    'ignore',
    message='BaseException.message has been deprecated as of Python 2.6',
    category=DeprecationWarning,
    module='argparse')

#Error Handling
import novaclient
from novaclient import exceptions 
from pyrax import exceptions
class Prospero (Exception):

     """Prospero  unspecified error."""

     pass

class CalibanError(Exception):

     """Caliban unspecified error."""

     pass

class ArielError(Exception):

     """Ariel unspecified error."""

     pass

class Miranda:

    def __init__(self, sections, base, file=False, option=None):
        self.sections = sections
        self.option = option
        self.defaults = option
        self.base = base
        self.file = file
        self.setpaths()

        prefab = ConfigObj(list_values=True,interpolation=True)
        self.prefab = prefab

        if self.option and self.option == 'defaults':
            self.defaults=True
            self.custom=False

        elif self.option and self.options == 'custom':
            self.defaults=False
            self.custom=True

        self.define_sections()


    def define_sections(self):

        if self.sections:
            for section in self.sections:
                self.prefab[str(section)]={}
                self._build(section)

    def _build(self,section):

        if section == 'tempest':
            self._app(section)

        if section == 'server':
            self._server(section)

        if section == 'dns':
            self._dns(section)

        if section == 'files':
            self._files(section)

        if section == 'db':
            self._db(section)

        if section == 'lb':
            self._lb(section)

        if section == 'cbs':
            self._cbs(section)

        if section == 'net':
            self._net(section)

    def setpaths(self):

        self.home = os.path.expanduser('~/')
        filestr = str(self.file)
        self.tmpfile = filestr.replace("cfg","tmp")
        self.bakfile = filestr.replace("cfg","bak")
        self.filepath = os.path.join(self.base,self.file)
        self.tmppath = os.path.join(self.base,'tmp')
        self.bakpath = os.path.join(self.base,'backups')
        self.prefabpath = os.path.join(self.base,'prefabs')
        self.uploadpath = os.path.join(self.base,'uploads')
        self.logpath = os.path.join(self.base,'logs')


    def load(self):
        prefab = ConfigObj(self.filepath)
        self.prefab = prefab
        return

    def save(self):

        tmpfile  = os.path.join(self.tmppath,self.tmpfile)
        backup = os.path.join(self.bakpath,self.bakfile)

        self.prefab.filename = tmpfile
        self.prefab.write()

        if os.path.exists(self.filepath):
            os.rename( self.filepath , backup )
         
        os.rename( tmpfile , self.filepath )

        return

    def get(self,section,item=False):

        if not item:
           value = self.prefab[section][item]
        else:
           value = self.prefab[section][item]

        return value


    def argwalk(self,arguments):
        for section in self.prefab:
            for item in self.prefab[section]:
                if not item == "description": 
                    value = self.prefab[section][item]
                    d = {item: value}
                    arguments.set_defaults( **d )
                    arguments.parse_args()            
        return arguments

    def show(self):

        for section in self.prefab:
            print
            print "[%s]" %section
            for item in self.prefab[section]:
                value = self.prefab[section][item]
                print item, " = " , value
        print
        return


    def _app(self,section):

        if self.defaults:

            make_dir(self.base)
            make_dir(self.prefabpath)
            make_dir(self.logpath)
            make_dir(self.uploadpath)
            make_dir(self.tmppath)
            make_dir(self.bakpath)

            self.prefab[str(section)]['description'] = 'Application Defaults'
            self.prefab[str(section)]['configpath'] = self.base
            self.prefab[str(section)]['config'] = self.file
            self.prefab[str(section)]['uploadpath'] = self.prefabpath
            self.prefab[str(section)]['default_upload'] = 'index.htm'
            self.prefab[str(section)]['prefabpath'] = self.prefabpath
            self.prefab[str(section)]['logpath'] =self.logpath
            self.prefab[str(section)]['logfile'] ='tempest.log'
            self.prefab[str(section)]['pyraxpath'] =self.home
            self.prefab[str(section)]['default_pyrax'] ='.pyrax.cfg'
            self.prefab[str(section)]['identpath'] =self.base
            self.prefab[str(section)]['default_ident'] ='.tempest.id'

            return

    def _server(self,section):

        if self.defaults:
            self.prefab[str(section)]['description'] = 'Cloud Server Defaults'
            self.prefab[str(section)]['image'] = '8a3a9f96-b997-46fd-b7a8-a9e740796ffd'
            self.prefab[str(section)]['flavor'] = 2
            self.prefab[str(section)]['srvprefix'] = 'tempest'

            return

    def _dns(self,section):

        if self.defaults:
            self.prefab[str(section)]['description'] = 'Cloud DNS Defaults'
            self.prefab[str(section)]['zone'] = 'tempest.example.com'
            self.prefab[str(section)]['record'] = 'A'
            self.prefab[str(section)]['TTL'] = 300
            self.prefab[str(section)]['email'] = 'webmaster@%s' %self.prefab[str(section)]['zone']

            return

    def _files(self,section):

        if self.defaults:
            html = open(os.path.join(self.uploadpath,"index.htm") , 'wb')
            html .write(default_html)
            self.prefab[str(section)]['description'] = 'Cloud Files Defaults'
            self.prefab[str(section)]['container'] = 'tempest'
            self.prefab[str(section)]['cdn'] = 'False'
            self.prefab[str(section)]['uploadpath'] = self.uploadpath
            self.prefab[str(section)]['upload'] = 'index.htm'
            self.prefab[str(section)]['html'] = default_html

            return

    def _db(self,section):

        if self.defaults:
            self.prefab[str(section)]['description'] = 'Cloud Databases Defaults'
            self.prefab[str(section)]['dbtype'] = 'MySQL'
            self.prefab[str(section)]['dbprefix'] = 'tempestdb'
            self.prefab[str(section)]['flavor'] = 2
            self.prefab[str(section)]['volume'] = 2

            return

    def _lb(self,section):

        if self.defaults:
            self.prefab[str(section)]['description'] = 'Cloud LoadBalancer Defaults'
            self.prefab[str(section)]['port'] =80
            self.prefab[str(section)]['algorithm'] = 'least connections'
            self.prefab[str(section)]['lbprefix'] = 'tempestlb'

            return

    def _cbs(self,section):

        if self.defaults:
            self.prefab[str(section)]['description'] = 'Cloud Block Storage Defaults'
            self.prefab[str(section)]['datastore'] = 'cloudstore'
            self.prefab[str(section)]['type'] = 1
            self.prefab[str(section)]['bsprefix'] = 'tempestcbs'

            return

    def _net(self,section):

        if self.defaults:
            self.prefab[str(section)]['description'] = 'Cloud Networks Defaults'
            self.prefab[str(section)]['networks'] = ""
            self.prefab[str(section)]['netprefix'] = 'tempestnet'

            return

class Ariel:

   def __init__(self,username=False,apikey=False,ident=False,pyrax=False,keyring=False):
       self.username = username
       self.apikey = apikey
       self.ident  = ident
       self.username = username
       self.pyrax = pyrax
       self.keyring = keyring
       self.auth()
       return

   def genkeyring ( self, keyname):
       print "Creating keyring: %s" %keyname
       print "User Name: %s" %self.username
       print "API Key: %s" %self.apikey
       try: keyring.set_password( str(keyname), str(self.username), str(self.apikey) )
       except NameError: 
          pass
       return

   def uuid_to_name(self,obj_type,objlist):
       console.debug('uuid_to_name')

   def create(self,obj_type,mode=False,**kwargs):             
       console.debug(mode)
       console.debug('Object: %s' %obj_type)
       console.debug('Add: %s' %args )
       if obj_type == "server" and args:
          self._srv_create(mode,**kwargs)

   def _srv_create(self,mode,id,image,flavor,net):
       console.debug(mode)
       console.debug('Name: %s' %id )
       console.debug('Flavor: %s' %flavor )
       console.debug('Image: %s' %image )
       if mode == 'dry_run':
           server = False
       else:
           try:
               img = self._img_valid(image)
               flv= self._flv_valid(flavor)
               if net:
                   server = self.cslist.servers.create(str(id),img,flv,net)
               else:
                   server = self.cslist.servers.create(str(id),img,flv)
               if server:
                   console.info( "ID: %s" %str(server.id) )
                   console.info( "Status: %s" %server.status )
                   console.info( "Admin password: %s" %server.adminPass )
                   console.info( "Networks: %s" %server.networks )
           except novaclient.exceptions.BadRequest as err:
               console.error(str(err))
               pass

   def delete(self,obj_type,mode=False,**kwargs):
       console.debug(mode)
       console.debug('Delete: %(obj_type) %(args)')
       try:
          if obj_type == "server":
              self._srv_delete(mode,**kwargs)
          if obj_type == "image":
              self._img_delete(mode,**kwargs)
       except Exception:
           console.error("Unable to delete object with uuid or name: %s" %uuid)
           pass
           return

   def clone(self,obj_type,mode=False,**kwargs):
       if obj_type == "server":
           self._srv_clone(mode,**kwargs)
       if obj_type == "image":
           self._img_clone(mode,**kwargs)

   def _srv_image(self,server,name):
       console.debug('Image: %s' %server)
       image = server.create_image(name)
       return image

   def _srv_clone(self,obj,mode,namelist):
       debug.console(mode)
       debug.console('Name list: %s' %namelist)
       server = self._srv_valid(obj)
       now  = datetime.datetime.now()
       imagename = server.name + '.' + now.strftime('%Y%m%d%H%M')
       console.debug('Imaging: %s' %obj + 'as %s' %imagename )
       image = self._srv_image(server,imagename) 
       console.info("wating for new server image to become available.")

   def _img_clone(self,obj,namelist,mode=False):
       image = self.valid("image",uuid)
       if image:
          for name in namelist:
             console.debug(name)
             server = self.create('server',name,uuid)


   def _srv_delete(self,mode,uuid):
       console.debug(mode)
       server = self._srv_valid(uuid)
       console.debug('Delete: %s' %server)
       try:
            console.info ( "ACTION: deleted server with UUID: %s" %uuid )
            if not mode == 'dry_run':
                server.delete()
       except Exception:
            console.error("unable to delete UUID: %s" %uuid)
            pass
            return

   def _img_delete(self,mode,uuid):
       console.debug(mode)
       image = self.valid("image",uuid)
       console.debug('Delete: %s' %image)
       all_imgs = self.cslist.images.list()
       images = [img for img in all_imgs if hasattr(img, 'server')] 
       if not images:
           console.warn ("there are no images to delete.")
           exit()
       elif not uuid and mode == 'interactive':
           img_dict = {}
           for pos, img in enumerate(images):
               print "%s: %s" % (pos, img.name)
               img_dict[str(pos)] = img
               selection = None
               while selection not in img_dict:
                  if selection is not None:
                      console.warn ( "Invalid choice")
                      question = "Enter the image number:" 
                      selection = getanswer(question)
                      image = img_dict.get(selection)
                      delete_me = img.id
       elif not mode and uuid:
           delete_me=uuid
       if delete_me:
           self.cslist.images.delete(delete_me)
           console.info ("Image with UUID '%s' has been deleted." % delete_me)
       else:
           console.error ("Unable to find the image with UUID '%s' in your list of server images." % delete_me)

   def valid(self,obj_type,obj):

       try:
           if obj_type == "server":
               return self._srv_valid(obj) 
           if obj_type == "flavor":
               return self._flv_valid(obj) 
           if obj_type == "image":
               return self._img_valid(obj) 
       except Exception:
           console.error("Unable to find object with uuid or name: %s" %obj)
           pass

   def _srv_valid(self,id):
        server = self.cslist.servers.get(str(id))
        if server.name:
           console.debug('Valid: %s' %server)
           return server

   def _img_list(self,img_type=False):
        all_imgs = self.cslist.images.list()
        if not img_type:
            imgs = all_imgs
        else:
            imgs = [img for img in all_imgs if hasattr(img, img_type)]
        for img in imgs:
            print img.name, " UUID:", img.id
        return

  
   def _net_list(self,net_type=False):
        self.net.list()

   def _flv_list(self):
        flvs = self.cslist.flavors.list()
        for flv in flvs:
            print "Name:", flv.name
            print "  ID:", flv.id
            print "  RAM:", flv.ram
            print "  Disk:", flv.disk
            print "  VCPUs:", flv.vcpus
        return

   def _img_valid(self,image):
        matchcount = 0
        imgs = self.cslist.images.list()
        idmatch = False
        for img in imgs:
           if image in img.name:
              idmatch = img.id
              matchcount += 1
              print "Image Name: %s" %img.name
              print "Image ID: %s" %img.id
           elif image in img.id:
              idmatch = img.id
              matchcount += 1
              print "Image Name: %s" %img.name
              print "Image ID: %s" %img.id
        if matchcount > 1:
           console.error ("more than one image match was found. Please, be more specific in your request, e.g. -i 'CentOS 6.0'")
           exit()
        elif not idmatch:
           console.error ( "The image, %s , was not found in the list of available images. Please, check the value and try again." %image )
           exit()
        else:
           return idmatch

   def _flv_valid(self,flavor):
        console.debug('Flavor: %s' %flavor)
        matchcount = 0
        flvs = self.cslist.flavors.list()
        idmatch = False
        for flv in flvs:
            if str(flavor) in str(flv.id):
               idmatch = flv.id
               matchcount += 1
               print "Flavor ID: %s" %flv.id
               print "Flavor RAM: %s" %flv.ram
            elif str(flavor) == str(flv.ram):
               print "Flavor ID: %s" %flv.id
               print "Flavor RAM: %s" %flv.ram
               matchcount += 1
               idmatch = flv.id
        if matchcount > 1:
            console.error (" More than one flavor match was found. Please, be more specific in your request, e.g. -f 4096 or -f 3")
            exit()
        elif not idmatch:
            console.error ( "ERROR: The flavor, %s , was not found in the list of available flavors. Please, check the value and try again." %flavor)
            exit()
        else:
            return idmatch


   def show(self,obj_type,id):

       if obj_type == "server":
          try:
              self._srv_show(id)
          except Exception:
              logger.exception("Unable to find object with uuid or name: %s" %id)
              console.error("Unable to find object with uuid or name: %s" %id)
              pass

   def get(self,obj_type,match,id):
        value = 'placekeeper'
        return value

   def _dns_list(self,obj_type):
       if obj_type == 'domain':
          for domain in self.dns.get_domain_iterator():
              print domain.name
              for rec in self.dns.get_record_iterator(domain):
                  print rec
              for sub in self.dns.get_subdomains_iterator(domain):
                  print sub.name
                  recs = sub.list_records()
                  for rec in self.dns.get_record_iterator(sub):
                      print rec
       if obj_type == 'PTR':
           print self.dns.list_ptr_records(device)

   def _dns_create(self,obj_type):
        value = 'placekeeper'
        return value
     

   def _srv_show(self,id):

       server = self.cslist.servers.get(id)
       try:
           print
           print "Server Name:", server.name
           print "Server ID:", server.id
           print "Server Status:", server.status
           print

       except Exception:
           logger.exception("Cloud Server object invalid or not found")
           console.error("Cloud Server object invalid or not found") 

           pass

       return

   def list(self,obj_type=False,list_type=False):

       if obj_type  == "server":
           self._srv_list()
       if obj_type  == "image":
           self._img_list(list_type)
       if obj_type  == "flavor":
           self._flv_list()

   def name_to_uuid(self,obj_type,namelist):
       uuidlist=[]
       for name in namelist:
           if obj_type == 'server':
               for server in self.cslist.list():
                   console.debug (server.name)
                   sublist = []
                   if str(server.name)  ==  name:
                      uuid = server.id
                      console.debug('Match: %(server.name) %(uuid)')
                      sublist.append(uuid)
                   if len(sublist) == 1:       
                      uuidlist =+sublist
                   elif len(sublist) == 0:
                      console.critical('no matches list of names, %s, please check and retry.' %namelist)
                      exit()
                   else:
                      console.critical('more than one match in the list of names, %s, please check and retry.' %namelist)
                      exit()
       return uuidlist
                    
   def _srv_list(self,status=False):
       active = False
       servers = self.cslist.servers.list()
       if servers:
           for server in servers:
               if server.status == "ACTIVE" or server.status == 'BUILD':
                   active = server
               elif server.status == "DELETED":
                   deleted = server
               if active:
                   self.show('server',active)
       else:
           console.warning("there are no active servers in your account.")
          
   
   def _files_show(self):
       print self.cfiles.get_account_metadata()
       print list_containers_info()


   def _connect(self):
       self.cslist  = pyrax.cloudservers
       self.dns = pyrax.cloud_dns
       #pyrax.cloud_dns.set_timeout(30)
       self.cfiles = pyrax.cloudfiles
       self.net = pyrax.cloud_networks
       self.db  = pyrax.cloud_databases
       self.lb = pyrax.cloud_loadbalancers
       self.bs = pyrax.cloud_blockstorage

   def auth(self):

       if pyrax.identity.authenticated:
           self._connect()
           return
       else:
           if self.username and self.apikey:
               try: pyrax.set_credentials(self.username, self.apikey)
               except: 
                   logger.warn("invalid user name or apikey, check the values and try again.")

           if not pyrax.identity.authenticated and self.ident:
               console.info ("using alternate pyrax identity file: %s" %self.ident)
               try:
                   with open(self.ident): pass
                   try: pyrax.set_credential_file(self.ident)
                   except NameError: pass 
               except IOError: pass 

           if not pyrax.identity.authenticated and self.pyrax and self.keyring:
               console.info ("using pyrax file: %s" %self.pyrax)
               try:
                   with open(self.pyrax): pass
                   try: pyrax.keyring_auth() 
                   except NameError: pass 
               except IOError: pass

           if not pyrax.identity.authenticated:
               console.warn("keyring and ident file authentication failed, trying manual authentication.")
               question = "What is your Rackspace Cloud Account User Name?"
               answer = getanswer(question)
               username = str (answer)
               pyrax.keyring_auth(username)

               if not pyrax.identity.authenticated:
                   question = "What is your Rackspace Cloud Account API key?"
                   answer = getanswer(question)
                   apikey = str (answer)
                   try: pyrax.set_credentials(username,apikey)

                   except: 
                      logger.critical (" manual login failed, no valid authentication method found.")
                      exit()

           if pyrax.identity.authenticated and pyrax.cloudservers:
               console.info("authentication sucessful")
               self._connect()

               return

class Caliban:

     def __init__(self,mode=False,prefab=False):
         self.parser = argparse.ArgumentParser(prog=__file__,description='Rackspace open cloud services command and control script using the pyrax Python API bindings', epilog="Pressing ctl+C at any time will exit the script. In interactive mode, x will exit the script.") #, add_help=True, formatter_class=argparse.ArgumentDefaultsHelpFormatter) 

         self.cl_mode()  
         if mode == "interactive":
              self.interactive()
         elif mode == "prefab":
              self.prefab(prefab)
       

     def interactive(self):

         self.cl_mode()  
         self.parser.set_defaults(number=3)
         self.args = self.parser.parse_args()

         return

     def cl_mode(self):
         self.parser = argparse.ArgumentParser(prog="prospero",description='Rackspace open cloud services command and control script using the pyrax Python API bindings', epilog="Pressing ctl+C at any time will exit the script. In interactive mode, x will exit the script.") #, add_help=True, formatter_class=argparse.ArgumentDefaultsHelpFormatter) 
         controlgroup = self.parser.add_argument_group('controls','options that control the script behaviour')
         controlgroup.add_argument('--dryrun', help="show commands to be run but do not commit them",action="store_true")
         controlgroup.add_argument('--debug', help="show debug output on the console",action="store_false")
         controlgroup.add_argument('--setup', help="setup initial script environment", choices = ['defaults','custom'], metavar='<setup type>')
         controlgroup.add_argument('--interactive', help="help",action="store_true")
         controlgroup.add_argument('--version', action='version', version = "0.02")
         controlgroup.add_argument('-q','--quiet', help="suppress verbose output",action="store_true" )
         controlgroup.add_argument('--config',  help="use this alternate configuration file",  metavar="<configuration file path>")
         authgroup = self.parser.add_argument_group('authentication','options that are used for authentication')
         authgroup.add_argument("-u","--username", help="Your Rackspace Cloud Account User Name")
         authgroup.add_argument("-k", "--apikey", help="Your Rackspace Cloud Account API Key")
         authgroup.add_argument('--pyrax', help="use a pryrax configuration file for credentials." , metavar='<pyrax config file path>')
         authgroup.add_argument('--ident', help="use this alternative identity file for pyrax credentials", metavar='<alt. pyrax identity file path>')
         objectgroup = self.parser.add_argument_group('objects', 'options for the --object option')
         objectgroup.add_argument("-O",'--object', help="the type of cloud object, e.g. server", type=str, choices=all_objects, metavar='<object type>')
         objectgroup.add_argument('-N','--name', help="the name(s) of the cloud object, e.g. for two server objects --name web1 web2", metavar ="<name(s)>", nargs='+', action='append')
         objectgroup.add_argument('-U','--uuid', help="the UUID(s) of the cloud object", type=str , metavar = "<UUID(s)>" , nargs='+', action='append')
         namegroup = self.parser.add_argument_group('names', 'options for the --autoname option used when generating multiple cloud objects of the same type')
         namegroup.add_argument('--autoname', help="automatically generate names when creating multiple objects", nargs=2, metavar='<name prefix> < simple|date >' )
         namegroup.add_argument('-n','--number', help="then number of cloud objects to add", default=1,type=int,  metavar = "<number>")
         optiongroup = self.parser.add_argument_group('options', 'options for each --object <object>')
         prefabgroup = self.parser.add_argument_group('--object prefab', 'options for --object prefab')
         prefabgroup.add_argument("--prefabs", help="the prefab file(s) to be used for --object prefab", metavar='<prefab file(s)>', nargs='+', action='append')
         servergroup = self.parser.add_argument_group('--object server', 'options for --object server')
         servergroup.add_argument('-i','--image', help="cloud server image uuid or name", metavar = '<name/uuid>')
         servergroup.add_argument('-f','--flavor', help="cloud server flavor id or RAM size, e.g. -f 512" ,metavar = '<flavor id|RAM size>') 
         dnsgroup  = self.parser.add_argument_group('--object dns', 'options for --object dns')
         dnsgroup.add_argument('-z','--zone', help="DNS zone / fully qualified domain name or subdomain name, TTL and the email of the domain manager", metavar = '<the fqdn for the (sub)domain zone> <TTL> <email>', nargs=3, action='append' )
         dnsgroup.add_argument('-r','--record', help="the DNS record type to add and the resource it is mapped to, e.g --record A 300 192.168.1.1 or --record CNAME 300 mail.example.com",  metavar = '<A|AAA|CNAME|TXT|MX> <TTL> [priority for M|] <ip|hostname>', nargs='?', action='append')
         dnsgroup.add_argument('--PTR', help="add a PTR record, e.g --object dns --action add --PTR 192.168.111.111 example.com",  nargs=2, metavar = '<IP address> <hostname>')
         dnsgroup.add_argument('--bind', help="a DNS zone BIND file to import",  metavar = '<BIND file>')
         filesgroup  = self.parser.add_argument_group('--object cloudfiles', 'options for  --object cloudfiles')
         filesgroup  = self.parser.add_argument_group('--object cdn', 'options for  --object cdn')
         filesgroup  = self.parser.add_argument_group('--object file', 'options for  --object file')
         filesgroup  = self.parser.add_argument_group('--object directory', 'options for  --object directory')
         dbgroup= self.parser.add_argument_group('--object clouddb', 'options for --object cloudb ,i.e a cloud datbase instance')
         dbgroup= self.parser.add_argument_group('--object db', 'options for --object db ,i.e a datbase running on a clouddb')
         dbgroup.add_argument('--volume', help="the cloud database instance storage volume size in GB, e.g. --volume 2", type=int , metavar='<volume size>' )
         lbgroup  = self.parser.add_argument_group('--object lb/loadbalancer', 'options for  --object lb/loadbalancer')
         lbgroup.add_argument('--port', help="loadbalancer port to listen on", metavar='<port number>')
         lbgroup.add_argument('--vip', help="virtual IP to assign to the loadbalancer object", metavar = '<virtual ip address>')
         lbgroup.add_argument('--algorithm', help="the cloud load balancer algorithm", choices = ['random','round _robin','weighted_round_robin','least_conns','weighted_least_conns'])
         bsgroup  = self.parser.add_argument_group('--object datastore', 'options for --object datastore')
         bsgroup.add_argument('--type', help="storage type", metavar = '<SATA|SSD>' , choices = ['sata','SATA','ssd','SSD'])
         netgroup  = self.parser.add_argument_group('--object network', 'options for --object network')
         netgroup.add_argument('--net', help="add this cloud object to the specified cloud server network(s) this cloud object" ,metavar = '<cloud network(s)>', nargs='+', action='append' ) 
         bsgroup.add_argument('--cidr', help="cidr of Cloud Network, e.g. 192.168.111.0/24", metavar = '<cidr>')
         actiongroup  = self.parser.add_argument_group('actions', 'options for the --object <object> --action  option')
         actiongroup.add_argument('-A','--action', nargs=1, choices=all_actions, help="action to be taken on cloud object or tempest script object") 


     def show(self):
                print self.parser.parse_args()

     def get(self):
         self.args = self.parser.parse_args()
         return self.args

     def prefab(self,prefab=False):
         #self.args = prefab.argwalk(self.parser)
         prefab.argwalk(self.parser)

     def check(self):

         if self.args.prefabs and not self.args.object == "prefab":
             self.parser.error('--prefabs requires --object prefab.')

         if self.args.object == "prefab" and self.args.action  in ['clone','edit','delete','show','rename'] and not self.args.prefabs:
            self.parser.error('the --object prefab %(args.action) option requires --prefab <file>.') 

         if self.args.image  and not self.args.object == "server":
            self.parser.error('-i/--image requires --object %(args.object).')

         if self.args.flavor  and not self.args.object == "server":
            self.parser.error('-f/--flavor requires --object %(args.object).')

         if self.args.action and not self.args.object:
            self.parser.error('--action requires --object.')

         if self.args.object and not self.args.action:
            self.parser.error('--object  requires --action.')

class Prospero:
  
    # Soliloqy
    def __init__(self,args,defaults):

        if args.debug:
            self.debug = args.debug
        if args.username:
            username = args.username
        if args.apikey:
            apikey = args.apikey
        if args.ident:
            ident = args.ident
        else:
            ident = os.path.join(defaults.get('tempest','identpath'),defaults.get('tempest','default_ident')) 
        if args.pyrax:
            pyrax = args.pyrax
        else:
            pyrax = os.path.join(defaults.get('tempest','pyraxpath'),defaults.get('tempest','default_pyrax')) 
    
        # The Tempest the grand illusion spun by Ariel at Prospero's demand 
        self.tempest = Ariel(args.username,args.apikey,ident,pyrax,True)

        # Get uuidlist,namelist and netlist control objects
        self.namelist = []
        self.uuidlist = []
        self.netlist = {}
        if args.uuid:
            self.uuidlist = args.uuid[0]

        if args.name:
            self.namelist = args.name[0] 

        if args.net:
            self.netlist['networks'] = args.net[0] 
            if len(self.netlist) > 10:
                console.error('accounts have a limit of 10 Cloud Networks, please, try again')
                exit()

        if args.autoname and args.number:
            self.namelist = autoname(args.object ,args.number,args.autoname)

        elif args.number >1 and len(namelist) == 1: 
            newauto = [namelist[0], 'simple']
            self.namelist = autoname(args.object ,args.number,newauto)

        if self.debug:
            console.debug('Args: %s' %args)
            self.tempest.list('Object: %s' %args.object)
            self.tempest.list('Action: %s' %args.action)
            if self.namelist:
                console.debug('Name(s): %s' %self.namelist)
            if self.uuidlist:
                console.debug('UUID(s): %s' %self.uuidlist) 
            if self.netlist:
                console.debug('Networks(s): %s' %self.netlist) 

        # Set mode for functions
        mode = False
        #mode = 'dry_run'
        if args.interactive:
            mode = 'interactive'

        if args.prefabs:
            mode = 'prefab'

        if args.dryrun:
            mode = 'dry_run'

        # --action list
        # Display lists of objects    
        if args.object and "list" in args.action:
            self.tempest.list(args.object)
            #return
            exit() 

        # --action show
        if args.object and "show" in args.action:
            if self.uuidlist:
                for uuid in self.uuidlist:
                    self.tempest.show(args.object,uuid)
                return
            elif self.namelist:
                for name in self.namelist:
                    self.tempest.show(args.object,name)
            else:
                console.error('you must provide the UUID or name of the object you want to show.')
                exit()

        obj_args = False 
        loop_obj = False 
        no_args = { } 
        # --action add
        if "add" in args.action:
            # --object server -- action
            if args.object == "server" and self.namelist:

                # Get default --object server --action add required arg values
                image  = defaults.get('server','image')
                flavor = defaults.get('server','flavor')

                if args.image:    
                    image = args.image

                if args.flavor:
                    flavor = args.flavor

                if self.namelist and image and flavor and netlist:
                    srv_args = { 'image': image, 'flavor': flavor, 'netlist': netlist } 
                    loop_obj = self.namelist

                if self.netlist:
                    #join the netlist to the argument list
                    obj_args = dict(srv_args.items() + self.netlist.items())
                else: 
                    obj_args = srv_args

        # --action de lete
        if "delete" in args.action:
            if args.object == "server" and self.uuidlist:
                loop_obj = self.uuidlist
                obj_args = no_args

        # --action clone
        if "clone" in args.action:
            if args.object == "server" and self.namelist and len(self.uuidlist) == 1:
                loop_obj = self.uuidlist
                obj_args = { 'namelist': self.namelist }
            else:
                console.error('Cloning of more than one object UUID, %s , is currently not suported.' %self.uuidlist)
                return

        if loop_obj and obj_args: 
             self.process(args.action[0],mode,loop_obj,args.object,**obj_args)
        return

    # Epilog   
    # Function to process objects
    def process(self,action,mode,loopobj,obj_type,**obj_args):
        console.debug(mode)
        console.debug(action)
        console.debug(obj_type)
        console.debug(obj_args)
        if self.debug: 
            if obj_type == 'image':
                self.tempest.list(obj_type,'server')
            else:
                self.tempest.list(obj_type)
        for id in loopobj:
            console.debug( "ACTION: %s" %action + ": %s" %id )
            if action == 'add':
                obj_args['id'] = id;
                self.tempest.create(obj_type,mode,**obj_args)
            elif action == 'delete':
                print 
                #self.tempest.delete(mode,obj_type,item,**obj_args)
            elif action == 'clone': 
                print 
            #tempest.clone(mode,obj_type,item,**obj_args)
            else:
                console.error ('ACTION: %s: unimplemented or not valid.' %action)  
        return

#Global Functions

def make_dir ( dir ):
    if not os.path.exists(os.path.expanduser(dir)):
        try: os.makedirs(dir)
        except OSError as exception:
            if exception.errno != errno.EEXIST:
                raise

def valid_file ( file ):

    if not os.path.exists(os.path.expanduser(file)):
        raise "The file %s does not exist!"%os.path.expanduser(file)
    else:
        return os.path.expanduser(file)

def getanswer(question, apppend=None):

     print question + append + '[x to exit]'
     response = raw_input()
     answer = str (response)
     if answer == "x":
         exit()
     else:
         return answer

# Function to automatically generate names
def autoname(self,obj_type,number,autoname):
    self.names = []
    prefix = str(autoname[0])
    autotype = str(autoname[1])

    for num in xrange ( 0, int(number) ):
        if autotype  == "simple":
            val = prefix + '.' + str(num+1)
            self.names.append( val )
        elif autotype == "date":
            now  = datetime.datetime.now()
            datestr = now.strftime('%Y%m%d%H%M')
            val = prefix + '.' + datestr + '.' + str(num+1)
            self.names.append( val )
        else:
            console.error("unkown autoname type %s", autotype)
    return self.names

# Logging
log.basicConfig(level=log.DEBUG,
                    format='%(asctime)s %(name)-12s %(levelname)-8s %(message)s',
                    datefmt='%m-%d %H:%M',
                    filename=logfile,
                    filemode='w')
logger = log.getLogger("tempest")
console = logger
fhandler = log.FileHandler( logfile )
fhandler.setLevel(log.DEBUG)
logger.addHandler(fhandler)
chandler = log.StreamHandler()
cformat = log.Formatter('%(levelname)-2s %(message)s')
chandler.setFormatter(cformat)
chandler.setLevel(log.INFO)
logger.addHandler(chandler)

def main():

    configfile = default_config
    base = default_base
    defaults  = Miranda( default_sections ,base,configfile)
    arguments = Caliban(defaults)
    defaults.load()
    args = arguments.get()

    if args.interactive or not args:
        interactive  = Caliban("interactive")
        args = interactive.get()
        print args.number
        exit()

    if args.setup == "defaults":
        defaults  = Miranda( default_sections,default_base,default_config,args.setup)
        default_args = Caliban(defaults)
        defaults.save()
        defaults.load()
        defaults.show()
        exit()

    if args.config:
        configfile = args.config
        base = os.path.basename(configfile)
        defaults = Miranda( default_sections ,base,configfile)
        arguments = Caliban(configfile)
        args = arguments.get()
        defaults.load()
        if args.debug:
            arguments.show()
            defaults.show()

    configpath = os.path.join ( os.path.expanduser(base) , configfile)

    if args.quiet:
        fhandler.setLevel(log.INFO)
        chandler.setLevel(log.CRITICAL)

    if args.debug:
        fhandler.setLevel(log.DEBUG)
        chandler.setLevel(log.DEBUG)

    if not args.quiet:
        console.info ("Verbose: True")
        if args.debug:
            console.info ("Debug: True")
        if args.dryrun:
            console.info ("Dry Run: True")
        console.info("Config File: %s" %configpath)
        console.info ("Log File: %s" %logfile)


    console.debug ( "name(s): %s" %args.name)
    if args.object == 'config' and "show" in args.action:
        defaults.show()

    Prospero(args,defaults)
    return

if __name__ == "__main__":
    
    try:
        main()
    except KeyboardInterrupt:
        pass

