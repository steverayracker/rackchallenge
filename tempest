#!/usr/bin/python
import datetime
import itertools
import pyrax
import argparse
import logging as log
import ConfigParser
import configobj
from configobj import ConfigObj
import os,sys
import re
import signal
import errno
import warnings
import keyring
import time
import traceback

#
# The Tempest - a Rackspace cloud command and control script using the pyrax bindings to the OpenStack API
# https://en.wikipedia.org/wiki/The_Tempest
# All apologies to Wm. Shakespeare
#Dramatis Personae 
# Prosepero   - the magister gives the commands
#               https://en.wikipedia.org/wiki/Prospero
#               command process control and argument interpreter
# Miranda     - the witness to it all and the future
#               https://en.wikipedia.org/wiki/Miranda_%28The_Tempest%29
#               configuration management and prefab generation tools
# Caliban     - the slave who does all the work
#               https://en.wikipedia.org/wiki/Caliban_%28The_Tempest%29
#               argument setup and processing
# Ariel       - the performer of the real magic
#               https://en.wikipedia.org/wiki/Ariel_%28The_Tempest%29
#               class using pyrax to make API calls
#

# Globals
global logfile
# Defaults
default_base = os.path.expanduser("~/.tempest")
default_pyrax = os.path.expanduser("~/.pyrax.cfg")
default_networks = {'public': True, 'private': True}
default_config = 'tempest_defaults.cfg'
default_html = "<html>Default %s index.html</html>" %__file__
logfile = os.path.join(default_base,'logs','tempest.log')
prefab_lilst = os.path.join(default_base,'prefabs','prefab.lst')
default_sections = ["tempest","server","dns","files","db","lb",'net','cbs']

tempest_objects=['config','auth','prefab']
cloud_objects=['server','image','flavor','dnszone','subdomain','dnsrecord','cloudfiles','cdn','file','tmpurl','clouddb','db','dbuser','cloudlb','lbnode','lbssl','lbmonitor','lbacl','lberror','lbcache','cbstore','snapshot','net']
common_actions=['list', 'show','add', 'delete', 'rename', 'edit', 'clone','on','off']
prefab_actions=['run']
server_actions=['resize', 'revert', 'confirm','reboot']
db_actions=['resize']
lb_actions=['enable','disable','draining']
files_actions=['upload','download','sync','copy','move']
dns_actions=['import','export']
bs_actions=['attach','detach']

all_objects = tempest_objects + cloud_objects
#all_actions = common_actions + prefab_actions + server_actions + dns_actions + files_actions + db_actions + lb_actions + bs_actions
all_actions = common_actions + prefab_actions + server_actions  + files_actions + dns_actions + lb_actions + bs_actions

# Global Logging
log.basicConfig(level=log.DEBUG,
                    format='%(asctime)s %(name)-12s %(levelname)-8s %(message)s',
                    datefmt='%m-%d %H:%M',
                    filename=logfile,
                    filemode='w')
logger = log.getLogger("tempest")
console = logger
fhandler = log.FileHandler( logfile )
fhandler.setLevel(log.DEBUG)
logger.addHandler(fhandler)
chandler = log.StreamHandler()
cformat = log.Formatter('%(levelname)-2s %(message)s')
chandler.setFormatter(cformat)
chandler.setLevel(log.INFO)
logger.addHandler(chandler)

#Global Functions

def make_dir ( dir ):
    if not os.path.exists(os.path.expanduser(dir)):
        try: os.makedirs(dir)
        except OSError as exception:
            if exception.errno != errno.EEXIST:
                raise

def valid_file ( file ):

    if not os.path.exists(os.path.expanduser(file)):
        raise "The file %s does not exist!"%os.path.expanduser(file)
    else:
        return os.path.expanduser(file)

def getanswer(question, apppend=None):

     print question + append + '[x to exit]'
     response = raw_input()
     answer = str (response)
     if answer == "x":
         exit()
     else:
         return answer

# Function to automatically generate names
def autoname(self,obj_type,number,autoname):
    self.names = []
    prefix = str(autoname[0])
    autotype = str(autoname[1])

    for num in xrange ( 0, int(number) ):
        if autotype  == "simple":
            val = prefix + '.' + str(num+1)
            self.names.append( val )
        elif autotype == "date":
            now  = datetime.datetime.now()
            datestr = now.strftime('%Y%m%d%H%M')
            val = prefix + '.' + datestr + '.' + str(num+1)
            self.names.append( val )
        else:
            console.error("unkown autoname type %s", autotype)
    return self.names

warnings.filterwarnings(
    'ignore',
    message='BaseException.message has been deprecated as of Python 2.6',
    category=DeprecationWarning) #,
    #module='argparse')

#Error Handling
import novaclient
from novaclient import exceptions 
from pyrax import exceptions
class Prospero (Exception):

     """Prospero  unspecified error."""

     pass

class CalibanError(Exception):

     """Caliban unspecified error."""

     pass

class ArielError(Exception):

     """Ariel unspecified error."""

     pass

class Miranda:

    def __init__(self, sections, base, file=False, option=None):
        self.sections = sections
        self.option = option
        self.defaults = option
        self.base = base
        self.file = file
        self.setpaths()

        prefab = ConfigObj(list_values=True,interpolation=True)
        self.prefab = prefab

        if self.option and self.option == 'defaults':
            self.defaults=True
            self.custom=False

        elif self.option and self.options == 'custom':
            self.defaults=False
            self.custom=True

        self.define_sections()


    def define_sections(self):

        if self.sections:
            for section in self.sections:
                self.prefab[str(section)]={}
                self._build(section)

    def _build(self,section):

        if section == 'tempest':
            self._app(section)

        if section == 'server':
            self._server(section)

        if section == 'dns':
            self._dns(section)

        if section == 'files':
            self._files(section)

        if section == 'db':
            self._db(section)

        if section == 'lb':
            self._lb(section)

        if section == 'cbs':
            self._cbs(section)

        if section == 'net':
            self._net(section)

    def setpaths(self):

        self.home = os.path.expanduser('~/')
        filestr = str(self.file)
        self.tmpfile = filestr.replace("cfg","tmp")
        self.bakfile = filestr.replace("cfg","bak")
        self.filepath = os.path.join(self.base,self.file)
        self.tmppath = os.path.join(self.base,'tmp')
        self.bakpath = os.path.join(self.base,'backups')
        self.prefabpath = os.path.join(self.base,'prefabs')
        self.uploadpath = os.path.join(self.base,'uploads')
        self.logpath = os.path.join(self.base,'logs')


    def load(self):
        prefab = ConfigObj(self.filepath)
        self.prefab = prefab
        return

    def save(self):

        tmpfile  = os.path.join(self.tmppath,self.tmpfile)
        backup = os.path.join(self.bakpath,self.bakfile)

        self.prefab.filename = tmpfile
        self.prefab.write()

        if os.path.exists(self.filepath):
            os.rename( self.filepath , backup )

        os.rename( tmpfile , self.filepath )

        return

    def get(self,section,item=False):

        if not item:
           value = self.prefab[section][item]
        else:
           value = self.prefab[section][item]

        return value


    def argwalk(self,arguments):
        for section in self.prefab:
            for item in self.prefab[section]:
                if not item == "description": 
                    value = self.prefab[section][item]
                    d = {item: value}
                    arguments.set_defaults( **d )
                    arguments.parse_args()            
        return arguments

    def show(self):

        for section in self.prefab:
            print
            print "[%s]" %section
            for item in self.prefab[section]:
                value = self.prefab[section][item]
                print item, " = " , value
        print
        return


    def _app(self,section):
        if self.defaults:
            make_dir(self.base)
            make_dir(self.prefabpath)
            make_dir(self.logpath)
            make_dir(self.uploadpath)
            make_dir(self.tmppath)
            make_dir(self.bakpath)
            self.prefab[str(section)]['description'] = 'Application Defaults'
            self.prefab[str(section)]['configpath'] = self.base
            self.prefab[str(section)]['config'] = self.file
            self.prefab[str(section)]['uploadpath'] = self.prefabpath
            self.prefab[str(section)]['default_upload'] = 'index.htm'
            self.prefab[str(section)]['prefabpath'] = self.prefabpath
            self.prefab[str(section)]['logpath'] =self.logpath
            self.prefab[str(section)]['logfile'] ='tempest.log'
            self.prefab[str(section)]['pyraxpath'] =self.home
            self.prefab[str(section)]['default_pyrax'] ='.pyrax.cfg'
            self.prefab[str(section)]['identpath'] =self.base
            self.prefab[str(section)]['default_ident'] ='.tempest.id'
        return

    def _server(self,section):
        if self.defaults:
            self.prefab[str(section)]['description'] = 'Cloud Server Defaults'
            self.prefab[str(section)]['image'] = '8a3a9f96-b997-46fd-b7a8-a9e740796ffd'
            self.prefab[str(section)]['flavor'] = 2
            self.prefab[str(section)]['srvprefix'] = 'tempest'
        return

    def _dns(self,section):
        if self.defaults:
            self.prefab[str(section)]['description'] = 'Cloud DNS Defaults'
            self.prefab[str(section)]['zone'] = 'tempest.example.com'
            self.prefab[str(section)]['record'] = 'A'
            self.prefab[str(section)]['TTL'] = 300
            self.prefab[str(section)]['email'] = 'webmaster@%s' %self.prefab[str(section)]['zone']
        return

    def _files(self,section):
        if self.defaults:
            html = open(os.path.join(self.uploadpath,"index.htm") , 'wb')
            html .write(default_html)
            self.prefab[str(section)]['description'] = 'Cloud Files Defaults'
            self.prefab[str(section)]['container'] = 'tempest'
            self.prefab[str(section)]['cdn'] = 'False'
            self.prefab[str(section)]['uploadpath'] = self.uploadpath
            self.prefab[str(section)]['upload'] = 'index.htm'
            self.prefab[str(section)]['html'] = default_html
        return

    def _db(self,section):
        if self.defaults:
            self.prefab[str(section)]['description'] = 'Cloud Databases Defaults'
            self.prefab[str(section)]['dbtype'] = 'MySQL'
            self.prefab[str(section)]['dbprefix'] = 'tempestdb'
            self.prefab[str(section)]['flavor'] = 2
            self.prefab[str(section)]['volume'] = 2
        return

    def _lb(self,section):
        if self.defaults:
            self.prefab[str(section)]['description'] = 'Cloud LoadBalancer Defaults'
            self.prefab[str(section)]['port'] =80
            self.prefab[str(section)]['algorithm'] = 'least connections'
            self.prefab[str(section)]['lbprefix'] = 'tempestlb'
        return

    def _cbs(self,section):
        if self.defaults:
            self.prefab[str(section)]['description'] = 'Cloud Block Storage Defaults'
            self.prefab[str(section)]['datastore'] = 'cloudstore'
            self.prefab[str(section)]['type'] = 1
            self.prefab[str(section)]['bsprefix'] = 'tempestcbs'
        return

    def _net(self,section):
        if self.defaults:
            self.prefab[str(section)]['description'] = 'Cloud Networks Defaults'
            self.prefab[str(section)]['networks'] = ""
            self.prefab[str(section)]['netprefix'] = 'tempestnet'
        return

class Ariel:

   def __init__(self,username=False,apikey=False,ident=False,pyrax=False,keyring=False):
       self.username = username
       self.apikey = apikey
       self.ident  = ident
       self.username = username
       self.pyrax = pyrax
       self.keyring = keyring
       self.auth()
       return

   def _connect(self):
       self.cslist  = pyrax.cloudservers
       self.dns = pyrax.cloud_dns
       #self.dns.set_timeout(30)
       self.cfiles = pyrax.cloudfiles
       self.nets = pyrax.cloud_networks
       self.db  = pyrax.cloud_databases
       self.lb = pyrax.cloud_loadbalancers
       self.bs = pyrax.cloud_blockstorage
       return

   def genkeyring ( self, keyname):
       print "Creating keyring: %s" %keyname
       print "User Name: %s" %self.username
       print "API Key: %s" %self.apikey
       try: keyring.set_password( str(keyname), str(self.username), str(self.apikey) )
       except NameError: 
          pass
       return

   def uuid_to_name(self,obj_type,objlist):
       console.debug('uuid_to_name')
       return

   def create(self,obj_type,mode=False,**kwargs):
       console.debug(mode)
       console.debug('Object: %s' %obj_type)
       console.debug('Add: %s' %kwargs )
       if obj_type == "server" and kwargs:
          self._srv_create(mode,**kwargs)
       if obj_type == "dns" and kwargs:
          self._dns_create(mode,**kwargs)
       if obj_type == "net" and kwargs:
          self._net_create(mode,**kwargs)
       if obj_type == "cloudfiles" or "cdn" and kwargs:
          self._files_create(mode,**kwargs)
       if obj_type == "cloudlb" or "lbnode" and kwargs:
          self._lb_create(mode,**kwargs)
       if obj_type == "clouddb" or "db" and kwargs:
          self._db_create(mode,**kwargs)
       if obj_type == "cbstore" and kwargs:
          self._bs_create(mode,**kwargs)
       return

   def _srv_create(self,mode,namelist,image,flavor,networks=False,public=True,private=True,cidrlist=False):
       console.debug('Name(s): %s' %namelist )
       console.debug('Flavor: %s' %flavor )
       console.debug('Image: %s' %image )
       public_string=""
       private_string=""
       if mode == 'dry_run':
           server = False
       else:
           try:
               img = self._img_valid(image)
               flv= self._flv_valid(flavor)
               add_nets = {}
               add_cidrs = []
               # networks only implies existing networks
               if networks:
                   if not cidrlist:
                       console.info("list of network names provided but no CIDRs assuming the networks matching names already exist.")
                   for network in networks:
                       test = self._net_valid(network)
                       if test:
                           add_nets["u'%s'" %network] = test
                   if add_nets == {}:
                       console.warning("No vaild networks in list: %s" %networks)
               # CIDRs only implies existing networks
               if cidrlist:
                   if not networks:
                       console.info("list of CIDRs provided but no list of network names assuming the networks matching CIDRs already exist.")
                   for cidr in cidrlist:
                       test = self._net_valid(cidr)
                       if test:
                           add_cidr.append(cidr)
                   if add_cidrs == []:
                       console.warning("No vaild networks in list: %s" %cidrlist)
               # Both CIDRs and networks implies creation of new networks
               if networks and cidrlist:
                   console.info("list of network names and list of CIDRs provided attempting to create new networks from the lists.")
                   if add_cidrs != []:
                       console.critical( 'CIDR(s): %s already exist unable to create new networki with the CIDR(s).' %cidrlist)
                       exit()
                   if add_nets != {}:
                       console.critical( "network(s): %s already exist unable to create new network(s)." %networks)
                       exit()
                   _net_create(mode,networks,cidrlist)
                   nets = self.nets.get_server_networks('public=%s' %public ,'private=%s' %private,add_nets)
                   console.debug("Nets: %s" %nets)
               for name in namelist:
                   if name and flv and img:
                       if not public or not private and nets:
                           server = self.cslist.servers.create(name,img,flv,networks=nets)
                       else:
                           server = self.cslist.servers.create(name,img,flv)
                   if server:
                       console.info( "ID: %s" %str(server.id) )
                       console.info( "Status: %s" %server.status )
                       console.info( "Admin password: %s" %server.adminPass )
                       console.info( "Networks: %s" %server.networks )
           except novaclient.exceptions.BadRequest as err:
               console.error(str(err))
               pass
       return

   def _dns_create(self,obj_type):
       value = 'placekeeper'
       return value

   def _lb_create(self,obj_type):
       value = 'placekeeper'
       return value

   def _db_create(self,obj_type):
       value = 'placekeeper'
       return value

   def _bs_create(self,obj_type):
       value = 'placekeeper'
       return value

   def _files_create(self,obj_type):
       value = 'placekeeper'
       return value

   def _net_create(self,mode,networks,cidrlist):
       console.debug("Network(s): %s" %networks)
       console.debug("CIDR(s): %s" %cidrlist)
       if len(networks) != len(cidrlist):
           console.critcal("the list of network names does not match the list of CIDRs.")
           exit()
       for network in networks:
           cidr = cidrlist.pop(0)
           self.nets.create("%s" %network, cidr="%s" %cidr)
       return

   def delete(self,obj_type,mode=False,**kwargs):
       console.debug('Delete: %s' %obj_type)
       try:
          if obj_type == "server":
              self._srv_delete(mode,**kwargs)
          elif obj_type == "image":
              self._img_delete(mode,**kwargs)
       except Exception:
           console.error("Unable to delete: %s" %obj_type)
           pass
       return

   def clone(self,obj_type,mode=False,**kwargs):
       if obj_type == "server":
           self._srv_clone(mode,**kwargs)
       if obj_type == "image":
           self._img_clone(mode,**kwargs)

   def _srv_image(self,mode,image,name):
       console.debug('Image: %s' %image)
       clone = image.create_image(name)
       return clone

   def _srv_clone(self,mode,namelist,uuidlist):
       console.debug(mode)
       console.debug(uuidlist)
       console.debug('Name list: %s' %namelist)
       server = self._srv_valid(uuidlist[0])
       now  = datetime.datetime.now()
       flavor = server.flavor.get('id')
       name = server.name + '.' + now.strftime('%Y%m%d%H%M')
       console.debug('Imaging: %s' %uuidlist[0] + 'as %s' %name )
       console.info("Please, wait for the new server image to become available.")
       image = self._srv_image(mode,server,name) 
       img_ready = self.cslist.images.get(image)
       if mode != 'dry_run':
           loopcount = 0
           while True:
               time.sleep(60)
               if loopcount > 0:
                   sys.stdout.write("\rElapsed: %s" %(loopcount * 60) )
               if img_ready.status == 'ACTIVE':
                   server = self._srv_create(mode,namelist,img_ready,flavor)
                   break
               else:
                   loopcount +=1
       return

   def _img_clone(self,mode,namelist,image,flavor):
       img = self._img_valid(image)
       flv = self._flv_valid(flavor)
       if img and flv:
          for name in namelist:
             console.debug(name)
             server = self._srv_create(mode,name,img,flv)
       return

   def _srv_delete(self,mode,uuidlist):
       console.debug(mode)
       for uuid in uuidlist:
           console.debug('UUID: %s' %uuid)
           server = self._srv_valid(uuid)
           console.debug('Delete: %s' %server)
           try:
               console.info ( "ACTION: deleted server with UUID: %s" %uuid )
               if not mode == 'dry_run':
                   server.delete()
           except Exception:
               console.error("unable to delete UUID: %s" %uuid)
               pass
       return

   def _img_delete(self,mode,uuidlist):
       console.debug(mode)
       console.debug(uuidlist)
       all_imgs = self.cslist.images.list()
       images = [img for img in all_imgs if hasattr(img, 'server')] 
       if not images:
           console.warn ("there are no images to delete.")
           exit()
       for uuid in uuidlist:
           console.debug('UUID: %s' %uuid)
           image = self.valid("image",uuid)
           console.debug('Delete: %s' %image)
           if not image and mode == 'interactive':
               img_dict = {}
               for pos, img in enumerate(images):
                   print "%s: %s" % (pos, img.name)
                   img_dict[str(pos)] = img
                   selection = None
                   while selection not in img_dict:
                       if selection is not None:
                            console.warn ( "Invalid choice")
                            question = "Enter the image number:" 
                            selection = getanswer(question)
                            image = img_dict.get(selection)
                            delete_me = img.id
           elif image:
              delete_me=uuid
           console.debug(delete_me)
           if delete_me:
              console.info ("Image with UUID '%s' has been deleted." % delete_me)
              if mode != 'dry_run':
                  try:
                      self.cslist.images.delete(delete_me)
                  except Exception:
                      console.error("unable to delete UUID: %s" %uuid)
           else:
               console.error ("Unable to find the image with UUID '%s' in your list of server images." % delete_me)
       return

   def validate(self,obj_type,obj):
        try:
            if obj_type == "server":
                return self._srv_valid(obj) 
            if obj_type == "flavor":
                return self._flv_valid(obj) 
            if obj_type == "image":
                return self._img_valid(obj) 
        except Exception:
            console.error("Unable to find object with uuid or name: %s" %obj)
            pass
        return

   def _srv_valid(self,id):
        server = self.cslist.servers.get(str(id))
        if server.name:
           console.debug('Valid: %s' %server)
           return server
        return

   def _net_valid(self,id):
        console.debug("Neti/CIDR: %s" %id)
        network = "label=%s" %id
        cidr = "label=%s" %id
        networks = self.nets.list()
        console.debug("Avaiable Networks: %s" %networks)
        try:
           if network in networks:
               console.debug('Valid: %s' %network)
               return network
        except novaclient.exceptions.NotFound as err:
            console.error(str(err))
            pass
        return

   def _img_list(self,img_type=False):
        all_imgs = self.cslist.images.list()
        if not img_type:
            imgs = all_imgs
        else:
            imgs = [img for img in all_imgs if hasattr(img, img_type)]
        print
        for img in imgs:
            print img.name, " UUID:", img.id
            print
        return

   def _lb_list(self,lb_type=False):
        lbs = self.lb.list()
        print
        for lb in lbs:
            print "Load Balancer:", lb.name
            print "ID:", lb.id
            print "Status:", lb.status
            print "Nodes:", lb.nodes
            print "Virtual IPs:", lb.virtual_ips
            print "Algorithm:", lb.algorithm
            print "Protocol:", lb.protocol
            print
        return

   def _net_list(self,net_type=False):
        nets = self.nets.list()
        print
        for net in nets:
            print net.name, " CIDR:", net.cidr
            print

   def _flv_list(self):
        flvs = self.cslist.flavors.list()
        for flv in flvs:
            print
            print "Name:", flv.name
            print "  ID:", flv.id
            print "  RAM:", flv.ram
            print "  Disk:", flv.disk
            print "  VCPUs:", flv.vcpus
            print
        return

   def _img_valid(self,image):
        matchcount = 0
        imgs = self.cslist.images.list()
        idmatch = False
        for img in imgs:
           if image in img.name:
              idmatch = img.id
              matchcount += 1
           elif image in img.id:
              idmatch = img.id
              matchcount += 1
        if matchcount > 1:
           console.error ("more than one image match was found. Please, be more specific in your request, e.g. -i 'CentOS 6.0'")
           exit()
        elif not idmatch:
           console.error ( "The image, %s , was not found in the list of available images. Please, check the value and try again." %image )
           exit()
        else:
           return idmatch
        return

   def _flv_valid(self,flavor):
        console.debug('Flavor: %s' %flavor)
        matchcount = 0
        flvs = self.cslist.flavors.list()
        idmatch = False
        for flv in flvs:
            if str(flavor) in str(flv.id):
               idmatch = flv.id
               matchcount += 1
               print "Flavor ID: %s" %flv.id
               print "Flavor RAM: %s" %flv.ram
            elif str(flavor) == str(flv.ram):
               print "Flavor ID: %s" %flv.id
               print "Flavor RAM: %s" %flv.ram
               matchcount += 1
               idmatch = flv.id
        if matchcount > 1:
            console.error (" More than one flavor match was found. Please, be more specific in your request, e.g. -f 4096 or -f 3")
            exit()
        elif not idmatch:
            console.error ( "ERROR: The flavor, %s , was not found in the list of available flavors. Please, check the value and try again." %flavor)
            exit()
        else:
            return idmatch
        return

   def show(self,obj_type,id):
        if obj_type == "server":
           try:
               self._srv_show(id)
           except Exception:
               console.error("Unable to find object with uuid or name: %s" %id)
               pass
        return

   def get(self,obj_type,match,id):
        value = 'placekeeper'
        return value

   def _dns_list(self,obj_type=False):
       for domain in self.dns.get_domain_iterator():
           print domain.name
           for rec in self.dns.get_record_iterator(domain):
               print rec
           for sub in self.dns.get_subdomains_iterator(domain):
               print sub.name
               recs = sub.list_records()
               for rec in self.dns.get_record_iterator(sub):
                   print rec
       if obj_type == 'PTR':
           print self.dns.list_ptr_records(device)
       return

   def _srv_show(self,id):
       server = self.cslist.servers.get(id)
       try:
           print
           print "Server Name:", server.name
           print "Server ID:", server.id
           print "Server Status:", server.status
           print
       except Exception:
           logger.exception("Cloud Server object invalid or not found")
           console.error("Cloud Server object invalid or not found") 
           pass
       return

   def list(self,obj_type=False,list_type=False):
       if obj_type  == "server":
           self._srv_list()
       if obj_type  == "image":
           self._img_list(list_type)
       if obj_type  == "flavor":
           self._flv_list()
       if obj_type  == "net":
           self._net_list()
       if obj_type  == "dns":
           self._dns_list()
       if obj_type  == "cloudlb":
           self._lb_list()
       return

   def name_to_uuid(self,obj_type,namelist):
       uuidlist=[]
       for name in namelist:
           if obj_type == 'server':
               for server in self.cslist.list():
                   console.debug (server.name)
                   sublist = []
                   if str(server.name)  ==  name:
                      uuid = server.id
                      console.debug('Match: %(server.name) %(uuid)')
                      sublist.append(uuid)
                   if len(sublist) == 1:       
                      uuidlist =+sublist
                   elif len(sublist) == 0:
                      console.critical('no matches list of names, %s, please check and retry.' %namelist)
                      exit()
                   else:
                      console.critical('more than one match in the list of names, %s, please check and retry.' %namelist)
                      exit()
       return uuidlist

   def _srv_list(self,status=False):
       active = False
       servers = self.cslist.servers.list()
       if servers:
           for server in servers:
               if server.status == "ACTIVE" or server.status == 'BUILD':
                   active = server
               elif server.status == "DELETED":
                   deleted = server
               if active:
                   self.show('server',active)
       else:
           console.warning("there are no active servers in your account.")
       return

   def _files_show(self):
       print self.cfiles.get_account_metadata()
       print list_containers_info()
       return

   def auth(self):
       if pyrax.identity.authenticated:
           self._connect()
           return
       else:
           if self.username and self.apikey:
               try: pyrax.set_credentials(self.username, self.apikey)
               except: 
                   logger.warn("invalid user name or apikey, check the values and try again.")

           if not pyrax.identity.authenticated and self.ident:
               console.info ("using alternate pyrax identity file: %s" %self.ident)
               try:
                   with open(self.ident): pass
                   try: pyrax.set_credential_file(self.ident)
                   except NameError: pass 
               except IOError: pass 

           if not pyrax.identity.authenticated and self.pyrax and self.keyring:
               console.info ("using pyrax file: %s" %self.pyrax)
               try:
                   with open(self.pyrax): pass
                   try: pyrax.keyring_auth() 
                   except NameError: pass 
               except IOError: pass

           if not pyrax.identity.authenticated:
               console.warn("keyring and ident file authentication failed, trying manual authentication.")
               question = "What is your Rackspace Cloud Account User Name?"
               answer = getanswer(question)
               username = str (answer)
               pyrax.keyring_auth(username)

               if not pyrax.identity.authenticated:
                   question = "What is your Rackspace Cloud Account API key?"
                   answer = getanswer(question)
                   apikey = str (answer)
                   try: pyrax.set_credentials(username,apikey)

                   except: 
                      logger.critical (" manual login failed, no valid authentication method found.")
                      exit()

           if pyrax.identity.authenticated and pyrax.cloudservers:
               console.info("authentication sucessful")
               self._connect()
       return

class Caliban:

     def __init__(self,mode=False,prefab=False):
         self.parser = argparse.ArgumentParser(prog=__file__,description='Rackspace open cloud services command and control script using the pyrax Python API bindings', epilog="Pressing ctl+C at any time will exit the script. In interactive mode, x will exit the script.") #, add_help=True, formatter_class=argparse.ArgumentDefaultsHelpFormatter) 

         self.cl_mode()  
         if mode == "interactive":
              self.interactive()
         elif mode == "prefab":
              self.prefab(prefab)

     def interactive(self):

         self.cl_mode()  
         self.parser.set_defaults(number=3)
         self.args = self.parser.parse_args()

         return

     def cl_mode(self):
         self.parser = argparse.ArgumentParser(prog="prospero",description='Rackspace open cloud services command and control script using the pyrax Python API bindings', epilog="Pressing ctl+C at any time will exit the script. In interactive mode, x will exit the script.") #, add_help=True, formatter_class=argparse.ArgumentDefaultsHelpFormatter) 
         controlgroup = self.parser.add_argument_group('controls','options that control the script behaviour')
         controlgroup.add_argument('--dryrun', help="show commands to be run but do not commit them",action="store_true")
         controlgroup.add_argument('--debug', help="show debug output on the console",action="store_false")
         controlgroup.add_argument('--setup', help="setup initial script environment", choices = ['defaults','custom'], metavar='<setup type>')
         controlgroup.add_argument('--interactive', help="help",action="store_true")
         controlgroup.add_argument('--version', action='version', version = "0.03")
         controlgroup.add_argument('-q','--quiet', help="suppress verbose output",action="store_true" )
         controlgroup.add_argument('--config',  help="use this alternate configuration file",  metavar="<configuration file path>")
         authgroup = self.parser.add_argument_group('authentication','options that are used for authentication')
         authgroup.add_argument("-u","--username", help="Your Rackspace Cloud Account User Name")
         authgroup.add_argument("-k", "--apikey", help="Your Rackspace Cloud Account API Key")
         authgroup.add_argument('--pyrax', help="use a pryrax configuration file for credentials." , metavar='<pyrax config file path>')
         authgroup.add_argument('--ident', help="use this alternative identity file for pyrax credentials", metavar='<alt. pyrax identity file path>')
         objectgroup = self.parser.add_argument_group('objects', 'options for the --object option')
         objectgroup.add_argument("-O",'--object', help="the type of cloud object, e.g. server", type=str, choices=all_objects, metavar='<object type>')
         objectgroup.add_argument('-N','--name', help="the name(s) of the cloud object, e.g. for two server objects --name web1 web2", metavar ="<name(s)>", nargs='+', action='append')
         objectgroup.add_argument('-U','--uuid', help="the UUID(s) of the cloud object", type=str , metavar = "<UUID(s)>" , nargs='+', action='append')
         objectgroup.add_argument('-T','--type', help="generic type delimiter for listing objects, e.g. --object dns --action list --type PTR", type=str , metavar = "<type>")
         objectgroup.add_argument('-M','--metadata', help="additional metadata of the cloud object", metavar ="<metadata key> <metadata value>", nargs=2, action='append')
         namegroup = self.parser.add_argument_group('names', 'options for the --autoname option used when generating multiple cloud objects of the same type')
         namegroup.add_argument('--autoname', help="automatically generate names when creating multiple objects", nargs=2, metavar='<name prefix> < simple|date >' )
         namegroup.add_argument('-n','--number', help="then number of cloud objects to add", default=1,type=int,  metavar = "<number>")
         optiongroup = self.parser.add_argument_group('options', 'options for each --object <object>')
         prefabgroup = self.parser.add_argument_group('--object prefab', 'options for --object prefab')
         prefabgroup.add_argument("--prefabs", help="the prefab file(s) to be used for --object prefab", metavar='<prefab file(s)>', nargs='+', action='append')
         servergroup = self.parser.add_argument_group('--object server', 'options for --object server')
         servergroup.add_argument('-i','--image', help="cloud server image uuid or name", metavar = '<name/uuid>')
         servergroup.add_argument('-f','--flavor', help="cloud server flavor id or RAM size, e.g. -f 512" ,metavar = '<flavor id|RAM size>', choices=['2','512','3','1024','4','2048','5','4096','6','8192']) 
         dnsgroup  = self.parser.add_argument_group('--object dnszone', 'options for --object dnszone')
         dnsgroup  = self.parser.add_argument_group('--object subdomain', 'options for --object subdomain')
         dnsgroup.add_argument('--email', help="the email of the domain manager", metavar = '<email>' )
         dnsgroup  = self.parser.add_argument_group('--object dnsrecord', 'options for --object dnsrecord')
         dnsgroup.add_argument('--ttl', help="DNS zone/record TTL", type=int, metavar = '<TTL in seconds>' )
         dnsgroup.add_argument('--record', help="the DNS record type to add and the resoure it is mapped to, e.g --record A 300 192.168.1.1 or --record CNAME 300 mail.example.com",  metavar = '<A|AAA|CNAME|TXT|MX> <TTL> [priority for M|] <ip|hostname>', nargs='?', action='append')
         dnsgroup.add_argument('--PTR', help="add a PTR record, e.g --object dns --action add --PTR 192.168.111.111 example.com",  nargs=2, metavar = '<IP address> <hostname>')
         dnsgroup.add_argument('--bind', help="a DNS zone BIND file to import",  metavar = '<BIND file>')
         dnsgroup.add_argument('--comment', help="a comment field for a DNS object",  metavar = '<comment (160 character max>')
         filesgroup  = self.parser.add_argument_group('--object cloudfiles', 'options for  --object cloudfiles')
         filesgroup  = self.parser.add_argument_group('--object cdn', 'options for  --object cdn')
         filesgroup  = self.parser.add_argument_group('--object file', 'options for  --object file')
         filesgroup  = self.parser.add_argument_group('--object directory', 'options for  --object directory')
         dbgroup= self.parser.add_argument_group('--object clouddb', 'options for --object cloudb ,i.e a cloud datbase instance')
         dbgroup.add_argument('--volume', help="the cloud database instance storage volume size in GB, e.g. --volume 2", type=int , metavar='<volume size>' )
         dbgroup.add_argument('--instance', help="the cloud database instance size , e.g. --instance 512" , metavar='<db instance id or RAM size>', choices=['1','512','2','1024','3','2048','4','4096'] )
         dbgroup= self.parser.add_argument_group('--object db', 'options for --object db ,i.e a datbase running on a cloud database instance')
         dbgroup= self.parser.add_argument_group('--object dbuser', 'options for --object dbuser')
         lbgroup  = self.parser.add_argument_group('--object lb', 'options for  --object lb')
         lbgroup.add_argument('--vip', help="virtual IP to assign to the loadbalancer object", metavar = '<PUBLIC/SERVICENET>', choices=['PUBLIC','public','SERVICENET','private'])
         lbgroup.add_argument('--algorithm', help="the cloud load balancer algorithm", choices = ['random','round_robin','weighted_round_robin','least_conns','weighted_least_conns'])
         lbgroup.add_argument('--persistence', help="the cloud load balancer session persistence settings", choices = ['HTTP_COOKIE','cookie','SOURCE_IP','ip'])
         lbgroup.add_argument('--protocol', help="the cloud load balancer protocol", choices = ['DNS_TCP', 'DNS_UDP', 'FTP', 'HTTP', 'HTTPS', 'IMAPS', 'IMAPv2', 'IMAPv3', 'IMAPv4', 'LDAP', 'LDAPS', 'MYSQL', 'POP3', 'POP3S', 'SFTP', 'SMTP', 'TCP', 'TCP_CLIENT_FIRST', 'UDP', 'UDP_STREAM'])
         lbgroup  = self.parser.add_argument_group('--object lbnode', 'options for  --object lbnode')
         lbgroup  = self.parser.add_argument_group('--object lbssl', 'options for  --object lbssl')
         lbgroup  = self.parser.add_argument_group('--object lbacl', 'options for  --object lbacl')
         bsgroup  = self.parser.add_argument_group('--object cbstore', 'options for --object cbstore')
         bsgroup.add_argument('--drive', help="storage harddrive type", metavar = '<SATA|SSD>' , choices = ['sata','SATA','ssd','SSD'])
         netgroup  = self.parser.add_argument_group('--object network', 'options for --object network')
         netgroup.add_argument('--net', help="add this cloud object to the specified cloud network(s), e.g. --net nopublic mynet == disable the public Internet, the private Rackspace internal net and your Cloud Network named mynet. Reserved Keywords:\n nopublic disable the public Internet\n noprivate disable the Rackspace private newtork\nNOTE: the public and private networks are enabled by default." ,metavar = '<cloud network(s)>', nargs='+', action='append' ) 

         netgroup.add_argument('--cidr', help="cidr() of Cloud Network, e.g. 192.168.111.0/24", metavar = '<cidr>', nargs='+',action='append')
         actiongroup  = self.parser.add_argument_group('actions', 'options for the --object <object> --action  option')
         actiongroup.add_argument('-A','--action', nargs=1, choices=all_actions, help="action to be taken on cloud object or tempest script object") 


     def show(self):
                print self.parser.parse_args()

     def get(self):
         self.args = self.parser.parse_args()
         return self.args

     def prefab(self,prefab=False):
         #self.args = prefab.argwalk(self.parser)
         prefab.argwalk(self.parser)

     def check(self):

         if self.args.prefabs and not self.args.object == "prefab":
             self.parser.error('--prefabs requires --object prefab.')

         if self.args.object == "prefab" and self.args.action  in ['clone','edit','delete','show','rename'] and not self.args.prefabs:
            self.parser.error('the --object prefab %(args.action) option requires --prefab <file>.') 

         if self.args.image  and not self.args.object == "server":
            self.parser.error('-i/--image requires --object %(args.object).')

         if self.args.flavor  and not self.args.object == "server":
            self.parser.error('-f/--flavor requires --object %(args.object).')

         if self.args.action and not self.args.object:
            self.parser.error('--action requires --object.')

         if self.args.object and not self.args.action:
            self.parser.error('--object  requires --action.')

# --- End Caliban ---

class Prospero:

    # Soliloqy
    def __init__(self,args,defaults):

        if args.debug:
            self.debug = args.debug
        if args.username:
            username = args.username
        if args.apikey:
            apikey = args.apikey
        if args.ident:
            ident = args.ident
        else:
            ident = os.path.join(defaults.get('tempest','identpath'),defaults.get('tempest','default_ident')) 
        if args.pyrax:
            pyrax = args.pyrax
        else:
            pyrax = os.path.join(defaults.get('tempest','pyraxpath'),defaults.get('tempest','default_pyrax')) 

        # The Tempest the grand illusion spun by Ariel at Prospero's demand 
        self.tempest = Ariel(args.username,args.apikey,ident,pyrax,True)

        # Get uuidlist,namelist and netlist control objects
        self.namelist = []
        self.uuidlist = []
        self.cidrlist = []
        self.netlist = default_networks
        if args.uuid:
            self.uuidlist = args.uuid[0]

        if args.name:
            self.namelist = args.name[0] 

        if args.net:
            netlist = args.net[0] 
            if len(netlist) > 1:
               netlist = list(set(self.netlist))
            for network in netlist:
               if network == 'nopublic':
                  self.netlist['public'] = False
               if network == 'noprivate':
                  self.netlist['private'] = False
            netlist[:] = [net for net in netlist if net != 'nopublic' and net !='noprivate' ]
            if len(netlist) > 10:
                console.error('accounts have a limit of 10 Cloud Networks, please, try again')
                exit()
            else:
                self.netlist['networks'] = netlist

        if args.cidr:
            console.debug("CIDR: %s" %args.cidr)
            cidrlist = args.cidr[0] 
            if len(cidrlist) > 1:
                cidrlist = list(set(self.cidrlist))
            console.debug(cidrlist)
            if len(cidrlist) > 10:
                console.error('accounts have a limit of 10 user defined Cloud Networks, please, try again')
                exit()
            else:
                self.cidrlist = cidrlist

        if args.autoname and args.number:
            self.namelist = autoname(args.object ,args.number,args.autoname)

        elif args.number >1 and len(namelist) == 1: 
            newauto = [namelist[0], 'simple']
            self.namelist = autoname(args.object ,args.number,newauto)

        if self.debug:
            console.debug('Args: %s' %args)
            self.tempest.list('Object: %s' %args.object)
            self.tempest.list('Action: %s' %args.action)
            if self.namelist:
                console.debug('Name(s): %s' %self.namelist)
            if self.uuidlist:
                console.debug('UUID(s): %s' %self.uuidlist) 
            if self.netlist:
                console.debug('Network(s): %s' %self.netlist) 
            if self.cidrlist:
                console.debug('Network CIDR(s): %s' %self.cidrlist) 

        # Set mode for functions
        mode = False
        #mode = 'dry_run'
        if args.interactive:
            mode = 'interactive'

        if args.prefabs:
            mode = 'prefab'

        if args.dryrun:
            mode = 'dry_run'

        # --action list
        # Display lists of objects    
        if args.object and "list" in args.action:
            self.tempest.list(args.object)
            #return
            exit() 

        # --action show
        if args.object and "show" in args.action:
            if self.uuidlist:
                for uuid in self.uuidlist:
                    self.tempest.show(args.object,uuid)
                return
            elif self.namelist:
                for name in self.namelist:
                    self.tempest.show(args.object,name)
            else:
                console.error('you must provide the UUID or name of the object you want to show.')
                exit()

        obj_args = False 
        no_args = { } 
        # --action add
        if "add" in args.action:
            # --object server -- actioni add
            if args.object == "server" and self.namelist:

                # Get default --object server --action add required arg values
                image  = defaults.get('server','image')
                flavor = defaults.get('server','flavor')

                if args.image:    
                    image = args.image

                if args.flavor:
                    flavor = args.flavor

                if self.namelist and image and flavor and self.netlist:
                    srv_args = { 'namelist': self.namelist, 'image': image, 'flavor': flavor} 

                if self.netlist:
                    #join the netlist to the argument list
                    obj_args = dict(srv_args.items() + self.netlist.items())
                else: 
                    obj_args = srv_args

            # --object net  -- action add
            if args.object == "net" and self.namelist and self.cidrlist:
                obj_args = {'networks': self.namelist, 'cidrlist': self.cidrlist}

        # --action delete
        if "delete" in args.action:

            if args.object == "server" or "image" and self.uuidlist:
                obj_args ={ 'uuidlist': self.uuidlist }

        # --action clone
        if "clone" in args.action:
            if args.object == "server" and self.namelist and len(self.uuidlist) == 1:
                obj_args = { 'uuidlist': self.uuidlist, 'namelist': self.namelist }
            elif len(self.uuidlist) < 1:
                console.critical('Cloning requires you to specify one server or image UUID to clone.')
            else:
                console.critical('Cloning of more than one object UUID, %s , is currently not suported.' %self.uuidlist)
                return

        if obj_args == no_args or obj_args: 
            console.debug (obj_args)
            self.command(args.action[0],args.object,mode,**obj_args)
        return

    # Epilog   
    # Function to process objects
    def command(self,action,obj_type,mode=False,**obj_args):
        if self.debug: 
            console.debug(mode)
            console.debug( "ACTION: %s" %action + ": %s" %obj_type )
            console.debug(obj_args)
            if obj_type == 'image':
                self.tempest.list(obj_type,'server')
            else:
                self.tempest.list(obj_type)
        if action == 'add':
            self.tempest.create(obj_type,mode,**obj_args)
            return
        elif action == 'delete':
            self.tempest.delete(obj_type,mode,**obj_args)
            return
        elif action == 'clone': 
            self.tempest.clone(obj_type,mode,**obj_args)
            return
        else:
            console.error ('ACTION: %s: unimplemented or not valid.' %action)  
        return
# --- End Prospero ---

def main():

    configfile = default_config
    base = default_base
    defaults  = Miranda( default_sections ,base,configfile)
    arguments = Caliban(defaults)
    defaults.load()
    args = arguments.get()

    if args.interactive or not args:
        interactive  = Caliban("interactive")
        args = interactive.get()
        print args.number
        exit()

    if args.setup == "defaults":
        defaults  = Miranda( default_sections,default_base,default_config,args.setup)
        default_args = Caliban(defaults)
        defaults.save()
        defaults.load()
        defaults.show()
        exit()

    if args.config:
        configfile = args.config
        base = os.path.basename(configfile)
        defaults = Miranda( default_sections ,base,configfile)
        arguments = Caliban(configfile)
        args = arguments.get()
        defaults.load()
        if args.debug:
            arguments.show()
            defaults.show()

    configpath = os.path.join ( os.path.expanduser(base) , configfile)

    if args.quiet:
        fhandler.setLevel(log.INFO)
        chandler.setLevel(log.CRITICAL)

    if args.debug:
        fhandler.setLevel(log.DEBUG)
        chandler.setLevel(log.DEBUG)

    if not args.quiet:
        console.info ("Verbose: True")
        if args.debug:
            console.info ("Debug: True")
        if args.dryrun:
            console.info ("Dry Run: True")
        console.info("Config File: %s" %configpath)
        console.info ("Log File: %s" %logfile)


    console.debug ( "name(s): %s" %args.name)
    if args.object == 'config' and "show" in args.action:
        defaults.show()

    Prospero(args,defaults)
    return

if __name__ == "__main__":

    try:
        main()
    except KeyboardInterrupt:
        pass

